### [Python](#Python)
* [什么是函数的参数](#函数的参数)
* [什么是高阶函数](#高阶函数)
* [什么是闭包](#闭包)
* [什么是装饰器](#装饰器)
* [什么是偏函数](#偏函数)
* [什么是迭代器](#迭代器)
* [什么是单例模式](#单例模式)
* [什么是多线程](#多线程)
* [什么是线程本地数据](#线程本地数据)
* [什么是多进程](#多进程)
* [什么是协程](#协程)

----------

## python
#### 函数的参数
包括位置参数、默认参数、可变参数、关键字参数、命名关键字参数
* 位置参数：定义后按顺序传入参数。```def test(x, y, z): ...```
* 默认参数：定义函数时，设定好参数的默认值。```def test(x, y, z="default"): ...```
* 可变参数：允许动态的传入参数。```def test(x, *args): ...```
* 关键字参数：允许动态的传入命名参数。```def test(x, *args, **kwargs): ...```
* 命名关键字参数：限定传入的命名参数。```def test(x, *args, key1, key2): ... ```

#### 高阶函数
一个函数可以接收另一个函数作为参数，或一盒函数返回值为函数，则称之为高阶函数


#### 闭包
当一个高阶函数，返回一个新函数的时候，高阶函数内部的局部变量被新函数引用，这种情况属于闭包。

更详细点就是，函数定义中引用了函数外定义的变量，并且该函数可以在其定义外环境被执行。


#### 装饰器
本质上，装饰器就是一个返回函数的高阶函数。
```
def decorator(func=None):
    def wrapper():
        return func()
    return wrapper
```


#### 偏函数
在python中可通过```functools.partial```来实现。原理就是对于一个已有函数，
通过将某些参数给固定住，从而返回一个新函数。调用这个新函数会更简单。
```
from functools import partial
new_func = partial(int, base=2)
print(new_func('123'))  # default base is 2
```


#### 迭代器
可以用做for循环的数据类型包括：
* 集合数据类型。包括list、dict、tuple、set、str等
* 生成器
可以直接作用于for循环的对象，统称为可迭代对象。Iterable

而可以被next()函数调用并不断返回下一个值的对象，统称为迭代器。Iterator。

可迭代对象可通过iter()函数转化为迭代器。


#### 单例模式
单例模式。在程序生命周期中，确保一个类只有一个实例。
```
class SingleInstance:
    instance = None
    def get_instance(self):
        if not self.instance:
            self.instance = True  # create one instance in here
        return self.instance
```


#### 多线程
首先得从`多任务`操作系统说起。多任务的意思就是：我们边听歌，边打游戏。就用户的感觉而言，
他们是一起执行的，当然后台肯定有其他任务也在一起执行。对于操作系统而言，
一个任务就是一个进程，一个进程，最少拥有一个线程，而线程就是CPU调度的最小单位。

所以线程是进程的一个子任务，多线程也就是进程中多个子任务并发执行。
实际上CPU单次调度只执行一个线程，并发的原理就是操作系统在多个线程之间快速切换，
让每个线程都短暂的交替运行。

python的多线程主要就是使用高级模块threading。而且的python的多线程很有特点。
以CPython为例，他受限于GIL全局排它锁，在某个threading编写多任务程序中，所有的线程，
只能在一个CPU中调度。调度其实是操作系统的事情，全局锁的意思就是，在每次线程切换的时候，
都会上锁。目的是为了保证线程之间数据一致性和状态同步。

因为多线程与多进程最大的不同，就是多进程中每个进程都有自己的一份数据拷贝，相互不影响。
而多线则共享其任务进程的数据资源，这也是GIL全局排他锁存在的原因。


#### 线程本地数据


#### 多进程


#### 协程
协程。我们也可以叫微线程。

在线程中，将每个函数的执行视为一个子程序。多个子程序之间的调用，必然为有序性和层次性。
而且一个子程序调用，总是一个入口，然后对应返回。

例如函数A调用了函数B，函数B中又调用了C，那么顺序为C调用结束后返回，接着B调用结束后返回，
最后才是A执行返回。这种是通过栈结构实现的。

协程不同。同一线程中，不同子程序之间的执行，是可中断的。中断处由开发人员设计，
中断后子程序内部保留既有属性与方法，转而执行其他子程序，在适当的时候在返回中断处继续执行。

异步编程中，最经典的就是异步回调式编程。也就在发生阻塞IO事件时，不进行显示的等待，
只是注册回调事件后转而执行其他程序。当阻塞事件完成后，即可执行已注册事件，继而完成后续的操作。
而协程式异步编程，则没有显示的回调逻辑，则整体编写的代码看上去与同步编程基本上是相同的。
因为协程本身中断后不会影响既有属性与方法，只需要重新激活协程即可继续执行后续代码。

本质上协程式异步编程，也是基于回调式。不过原生库asyncio帮我们封装好了回调逻辑。
将一个协程打包为一个Task任务并添加到期程，返回对应的未来对象。

总体流程就是：
发生IO耗时事件（常见的阻塞IO包括读写IO和网络IO，操作系统将事件分为两类，
也就是可读事件和可写事件）。程序会将此事件注册回调，转而执行其他程序，
当事件状态改变时即会触发回调。