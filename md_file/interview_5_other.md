### [Other](#Other)
* [部署](#部署)
* [什么是面向过程的程序设计](#面向过程的程序设计)
* [RabbitMQ](#RabbitMQ)
* [负载均衡](#负载均衡)
* [Nginx](#Nginx)
* [LVS](#LVS)
* [常规算法](#常规算法)

----------

## Other

#### 部署
* 蓝绿部署：
    * 是一种能够保证系统在不间断提供服务的情况下上线的部署方式。
    * 蓝绿部署中包含两个集群。在没有正式上线的情况下，集群A和B的代码版本是一致的。
    并且同时对外提供服务。在系统升级的时候，首先把一个集群，如A，从负载列表中一处，
    进行新的版本部署，集群B提供服务。<br>
    当集群A升级完毕后，把负载均衡指向集群A，再把B移除，进行部署升级，集群A重新提供服务。
    当B也升级完毕后，此时服务就基本没有中断了。
* 滚动部署：
    * 也是一种保证系统不间断提供服务的情况下，上线部署方式。
    * 但滚动部署只有一个集群，他是集群下不同的节点可以独立的进行版本升级。
    比如一个16节点的集群中。每次只升级4个节点，然后依次逐渐升级。
    * 整体比较来说：
        * 蓝绿部署：一次只有一个版本对外。容易定位问题。但是维护两个集群，成本较高。
        * 滚动部署：只需要维护一个集群，成本较低。但是两个版本对外，不容易定位
        问题。升级和回滚需要以节点为粒度，操作相对复杂。
* 灰度发布/金丝雀发布
    * 启动一个新的版本应用，并不直接将流量切过来，而是测试人员针对新版本进行测试。
    如果没有问题，就可以将少量的用户流量导入到这个新版本上，然后在对新版本进行光擦。
    常见的A/B测试，就是在此时收集数据并对比的。
    * 感觉华为那边用的就是这种回复发布。发布一个beta版本后由beta用户进行测试使用。
    大致没有问题后可以对外发布使用名额，引入少量流量，来观察并记录问题，优化后
    可持续导入流量。

#### 面向过程的程序设计
函数是编程语言通用的一种封装，通过将大段代码拆分为函数，通过一层一层的函数调用，
就可以把一个复杂任务拆分为多个简单任务，这种分解就是面向过程的程序设计。
而函数就是面向过程的程序设计的基本单元。

#### RabbitMQ
* broker: 消息队列服务器实体
* virtual host: 虚拟主机。默认vhost为/，每个vhost本质上就是一个mini版的rabbitmq服务器，拥有自己的队列、交换器、绑定和权限机制。可以理解为是一个自己的账号。
* exchange: 交换器，用来接收生产者发送给消费者的消息，并将这些消息路由给服务器的队列
* queue: 消息队列，用来保存消息知道发送给消费者。是消息的容器，也是消息的终点。一条消息可投入一个/多个队列。期间消息一直在队列中，等待消费者连接这个队列并取走。
* banding: 绑定，用于消息队列和交换机之间的关联。一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则，所以可以将交换器理解为一个由绑定构成的路由表。
* channel: 信道，多路复用连接中的一条独立的双向数据流通道。因为对于操作系统而言，建立和销毁TCP都有一定开销，故引入信道概念，复用一条TCP。<br>
amqp命令都是通过信道发出去的，如发布消息、订阅消息、或者或者是接收消息。
* connection: 网络连接。如TCP连接
* publisher: 消息生产者，可以使一个向交换器发布消息的客户端应用程序
* consumer: 消息消费者，从某消息队列取得消息的客户端应用程序
* message: 消息，消息不具名，由消息头和消息体组成。消息头由一系列可选属性组成，<br>
包括routing-key（路由键）、priority（优先级）、delivery-mode（消息可能需要序列化存储【消息的理由模式】）

exchange类型<br>
* direct: 消息中的路由键（routing-key）如果和binging中的binding-key一致。交换器就将消息队列发到对应的队列中。即路由与队列名完全匹配。
* fanout: 交换器的消息会分发到所有绑定的队列中。fanout交换器不处理该路由键，只是简单的将队列绑定到交换器上，<br>
每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。fanout类型转发消息最快。
* topic: topic交换器通过模式匹配分配消息的路由属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。<br>
识别两个通配符#*，#匹配多个单词，*则匹配一个单词。


#### 负载均衡
* HTTP重定向
    * 通过web服务器中的Location报文头，指向真正的工作服务器
* DNS负载均衡
    * 域名与IP相互映射到一个分布式数据库。通过域名，得到对应IP地址的过程叫做域名解析。
    而且是可以为多个不同的IP地址配置同一个域名。
    * DNS服务器充当主站点，将用户请求的域名映射为实际的IP地址，这种映射是可以一对多。
    * 在DNS服务器中，可以为多个不同的地址配置同一个域名，而最终查询这个域名的
    客户机将在解析这个名字时得到其中的一个地址。故同一个域名客户机可能会得到不同的地址。
    * 缺点：
        * 负载分配不均匀：DNS服务器将HTTP请求平均的分配到后台的服务器上。
        而不考虑每一台服务器的负载情况；如果后台的web服务器的配置和处理能力不同，
        则最慢的web服务器将成为系统的瓶颈，处理能力强的服务器则不能充分发挥作用。
        * 可用性低：如果后台某台web服务器故障，DNS服务器仍然会将请求分配到故障机上，
        导致无妨正常响应客户端。
        * 变更时间长，如果更改DNS有可能造成相当一部分用户无法正常访问web服务器。并且由于
        DNS缓存的原因，所造成的后果需要持续相当长的一段时间，一般为24小时。
* 反向代理
    * 反向代理的核心就是转发HTTP，任何实际服务器的HTTP请求都需要经过调度器，而调度器
    则等待实际服务器的HTTP响应，并将之反馈给用户。
* 基于四层交换技术的负载均衡
    * 代表：LVS、F5
    * 通过修改报文中的目标地址和端口，也就是将负载均衡所在服务器的地址，改为后端服务器IP地址，
    这样用户的请求就可以直接跟后端服务器建立TCP连接并发送数据。
    * 优点：性能高、支持各种网络协议。
    * 缺点：对网络依赖较大，负载智能化方面没有第七层负载好。比如不支持对url的个性化负载。
* 基于七层交换技术的负载均衡
    * 代表：nginx
    * 也叫内容交换，主要通过传递报文中真正有意义的应用层内容来实现。起一个反向代理的作用。
    客户端需要先于七层负载设备进行三次握手建立TCP连接，把套访问的数据报文信息发送给七层均衡负载；
    然后七层均衡负载再根据适当的规则选择web服务器，建立TCP连接，将数据发送给他进行处理。最后数据还是返回
    给七层均衡负载，负载均衡设备再把数据发送给client。
    * 缺点：性能没有4层负载高
    
#### Nginx
主要作用就是反向代理和负载均衡。<br>
* Nginx集群
    * 一般当Nginx作为外部唯一访问入口的时候，没有办法以集群的时候对外提供服务。<br>
    客户端的每一次请求，都需要先与nginx所在服务器建立TCP连接，并将相关报文信息传递，<br>
    之后由nginx所在服务器进行负载均衡分配，选择对应的web服务器，并将用户请求信息进行转交<br>
    * 一台nginx理论上最大并发应该在5w左右，即使是keepalived+nginx，实际上也只有一台机器在工作<br>
    面对更大并发的时候，就需要在其之上在加一层负载均衡器。

#### LVS
Linux Virtual Server，也就是linux虚拟服务机，是一个虚拟的服务器集群系统。
实现的三种方式：
* DR：direct route 直接路由
    * 请求有LVS接收，有真实提供服务的web服务器（RealServer，RS）直接返回给用户，返回的时候不仅过LVS。
    * DR模式下，要求LVS服务器与RS绑定在同一个VIP，一个请求发过来的时候，只需要将网络帧的MAC地址，<br>
    修改web服务器所在的MAC地址，该包就会被转发到响应的RS处理。<br>
    此时的源IP与目标IP都没有改变。RS接收到LVS转发过来的包，发现MAC是自己，IP地址也是自己，<br>
    于是就认为这个包是合法的，当RS返回请求的时候，只需要向源IP直接返回即可，不需要经过LVS。
    * 可以理解为转发了TCP的第一次握手?
    * 优点：性能非常高
    * 缺点：要求负载均衡服务器与RS在同一个物理字段。
* NAT：Network Address Translation网络地址转换
    * 是一种外网和内网地址映射的技术，在NAT模式下，LVS需要作为RS的网关。在网络包到达LVS的时候，<br>
    LVS做目标地址转化（DNAT），将目标IP改为RS的IP，<br>
    当RS接收到包之后，处理完，返回响应时，源IP是RS的IP，目标IP是客户端IP，这时RS的包通过网关LVS
    进行中转，此时LVS会做源地址转化（SNAT），将包的地址改为VIP，对于客户端，就只知道是LVS直接返回
    给他的了。
    * 缺点：LVS-NAT模式，请求和响应都需要经过LVS，性能没有DR模式好。
* TUN：tunnel 隧道
    * 通过IP隧道减轻LVS调度服务器的压力。一般的网络请求都是请求包很小，但是响应比较大，<br>
    负载均衡只负责把请求分发给物理服务器，而物理服务器将应答包直接发送给用户。所以负载均衡器能
    处理巨大的请求量，相比NAT性能好很多。<br>
    比DR模式的优点是不限制负载均衡器与RS在同一个物理段。
* 集群优化之路：
    * 首先是nginx负载，客户端需要先与nginx所在服务器进行TCP连接，然后由nginx所在服务器转发数据<br>
    所以理论上nginx最大并发量会被限制在5w+
    * 此时需要在nginx的上游做处理，引入LVS。若有LVS和nginx都在同一网段，那么可以直接使用DR模式<br>
    当LVS接收到请求时，直接修改此次请求的MAC地址，再转给负载均衡的RS，相当于直接转TCP的第一次握手<br>
    这种情况下，客户端直接与RS建立了TCP连接，进行直接的交互。<br>
    或者还可以使用NAT模式，也就是网络地址转化，此时LVS直接作为nginx集群服务器的网关，<br>
    每次当接收请求是，将请求的目标地址转化为RS所在服务器的IP地址，进行转发。服务器响应后<br>
    会直接返回数据，但是由于LVS处于网关位置，会接收到来自服务器的响应，此时再将源地址，改为VIP地址<br>
    对于客户端来说，该次请求还是LVS直接返回的。但是这种模式，LVS会存在一定的性能问题，一般的请求中<br>
    请求包的数据都是比较小的，而响应包就比较大，所以网络链路可能会是一个问题。<br>
    此时可以使用TUN，也就是ip隧道，此时LVS只负责将请求分发下去，而对应的服务器，接收请求后会直接
    发送给用户，相比NAT性能又好一些。
    * 当数据链路都是问题的时候，可以尝试从DNS负载均衡入手，也就是域名解析了。<br>
    可以使用LVS+keepalived来保证LVS的高可用性，但是这种还是只有一台服务器在工作<br>
    可以使用DNS负载均衡，对主备两台机子都有机会轮训使用。即使有一台服务器宕机，<br>
    还是可以使用另一台服务器。
    * 总体来说LVS还是存在一定的瓶颈。这是可以考虑LVS-ospf集群，<br>
    此种方法需要第三层交换机设备来实现。<br>
    或者使用多组双组结构来实现LVS的集群也是可以的。需要每台LVS都绑定一个vip（公网IP）<br>
    而DNS则设置为域名轮询多个IP
    * 原理：每次排序时，如按升序排序，则每次选择其中最小值，与第一位交换，
    以此类推，逐渐抽选目标值直至完成排序。
    * 直观点：每次遍历右边未排序的数据，然后从中取出目标值，与左边的进行交换。
    就这样先完成一个。
* 冒泡排序
    * 时间复杂度：O(n) ~ O(n^2)
    * 原理：从左到右，两两相比较。如按升序排序，则二者比较中较小者置于左侧。
    那么其实第一次就会将最大的数排到最后。后续遍历的时候可以相应的忽略最后位。
    * 直观点：每一次都遍历前面所有的队列数据，一步一步的把某个数据冒泡顶出来。
    每次总能定位好一个数据。
* 选择排序
    * 时间复杂度：O(n^2)
    * 原理：
    * 直观点：每一次遍历，选择当前位置的值为目标值，然后遍历后面的值，看知否有比他大或者小的值，
    有则获取目标值直至遍历结束，然后判断是否发生变化，是则替换目标值，将目标值放置首位。
* 插入排序
    * 时间复杂度：O(n) ~ O(n^2)
    * 原理：从左到右，每次新增一个，左边默认为已排序队列，右边每次取一个过来插入。
    * 直观点就是，左边增加一个，则进行一次排序。
* 希尔排序
    * 时间复杂度：O(n) ~ O(nlog2n)
    * 原理：基本和插入排序一样，不过引入了步长的概念。主要是为了弥补插入排序的缺陷，
    插入排序对于近似已排好序的序列来说，有很高的执行效率，基本达到线性排序。但插入效率比较低。
    一次只能插入一位，当数据较小数据在后面时，他需要一步一步的向前推进。也就是要进行n-1次比较和交换。
    引入步长step的概念。可以让目标位置朝着最终位置迈进一大步，更快的接近目标位置。
    * 直观点：比如长度为10的序列。步长为5.那么首先会将此序列切割为两个，然后第一个值和第六个值比较。
    看知否符合顺序。然后依次将各区间的值比较完成。
    最终步长会恢复到1，完成一次普通的插入排序，但这个时候的序列已经时接近排好序的序列。
* 二分插入排序
* 快速排序
* 归并排序
* 二叉树原理及实现
