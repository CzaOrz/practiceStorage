### [Python](#Python)
* [List](#list)
* [Dict](#dict)
* [什么是函数的参数](#函数的参数)
* [什么是高阶函数](#高阶函数)
* [什么是闭包](#闭包)
* [什么是装饰器](#装饰器)
* [什么是偏函数](#偏函数)
* [什么是迭代器](#迭代器)
* [什么是单例模式](#单例模式)
* [什么是多线程](#多线程)
* [什么是线程本地数据](#线程本地数据)
* [什么是多进程](#多进程)
* [什么是协程](#协程)

----------

## python
#### list
数据结构：有一个指针数组用来保存列表元素的指针，和一个可以在列表中放多少元素的标记
```
typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;  // 指向列表元素的指针数组
    Py_ssize_t allocated;  // 申请的内存的槽的个数
} PyListObject;
```
python中的list是对其他对象的引用组成连续数组。是一个动态数组，存储在一个连续的内存区块中，
。push和pop操作的复杂度为O(1)，但是插入和删除元素会造成内存块的移动，复杂度为O(n)。

#### dict
###### 解释器赋值：
* a = 'ABC': 解释器做了两件事
    * 在内存中创建了一个'ABC'的字符串对象
    * 在内存中创建了一个 a 的变量，并把它指向了 'ABC' 这个字符串对象
        
把一个变量a的值赋值给另一个变量b，实际就是把变量b指向了变量a所指向的数据
###### 可散列类型：
* 在可散列对象的生命周期中，他的散列值是不变的。需要实现__hash__和__eq__两个方法，
若两个可散列对象是相同的，则散列值一定是一样的
* ```a, b = "123", "".join(["1", "2", "3"])```,则```id(a) == id(b)  # False```，
因为二者已经不是同一对象，也就是```a is b  # False```，但值是相等的，即```a == b  # True```。
散列值/哈希值也是相等的```hash(a) == hash(b)  # True``` 
###### 稀疏数组：
* 所谓稀疏数组就是数组中大部分的内容都未被使用，或者都是零。<br>
数组中仅有少部分空间是有效使用的，因此有一定的空间浪费。

python中dict的底层数据结构是一个散列表，而散列表其实是一个稀疏数组<br>
散列表的里的每一个单元，我们称之为表元。也就是说在dict的散列表中，一个有效的表元其实分为两部分，
一个是对键的引用，一个是对值的引用。<br>
而表元大小一样，故可以通过偏移量来读取每一个表元。
##### 计算方式：
* 计算键的散列值
* 使用散列值中的一部分来定位散列表中的一个表元
    * 表元为空: 抛出异常KeyError
    * 键不相等:
        * 散列冲突
        * 取散列值另一部分来定位
        * 循环
    * 返回表元中的值

由于这种特性，导致字典：
1、键：必须为可散列，是为了能够唯一定位。
2、在空间上开销大：
3、散列冲突会导致字典内无序

#### 函数的参数
包括位置参数、默认参数、可变参数、关键字参数、命名关键字参数
* 位置参数：定义后按顺序传入参数。```def test(x, y, z): ...```
* 默认参数：定义函数时，设定好参数的默认值。```def test(x, y, z="default"): ...```
* 可变参数：允许动态的传入参数。```def test(x, *args): ...```
* 关键字参数：允许动态的传入命名参数。```def test(x, *args, **kwargs): ...```
* 命名关键字参数：限定传入的命名参数。```def test(x, *args, key1, key2): ... ```

#### 高阶函数
一个函数可以接收另一个函数作为参数，或一盒函数返回值为函数，则称之为高阶函数


#### 闭包
当一个高阶函数，返回一个新函数的时候，高阶函数内部的局部变量被新函数引用，这种情况属于闭包。

更详细点就是，函数定义中引用了函数外定义的变量，并且该函数可以在其定义外环境被执行。


#### 装饰器
本质上，装饰器就是一个返回函数的高阶函数。
```
def decorator(func=None):
    def wrapper():
        return func()
    return wrapper
```


#### 偏函数
在python中可通过```functools.partial```来实现。原理就是对于一个已有函数，
通过将某些参数给固定住，从而返回一个新函数。调用这个新函数会更简单。
```
from functools import partial
new_func = partial(int, base=2)
print(new_func('123'))  # default base is 2
```


#### 迭代器
可以用做for循环的数据类型包括：
* 集合数据类型。包括list、dict、tuple、set、str等
* 生成器
可以直接作用于for循环的对象，统称为可迭代对象。Iterable

而可以被next()函数调用并不断返回下一个值的对象，统称为迭代器。Iterator。

可迭代对象可通过iter()函数转化为迭代器。


#### 单例模式
单例模式。在程序生命周期中，确保一个类只有一个实例。
```
class SingleInstance:
    instance = None
    def get_instance(self):
        if not self.instance:
            self.instance = True  # create one instance in here
        return self.instance
```


#### 多线程
首先得从`多任务`操作系统说起。多任务的意思就是：我们边听歌，边打游戏。就用户的感觉而言，
他们是一起执行的，当然后台肯定有其他任务也在一起执行。对于操作系统而言，
一个任务就是一个进程，一个进程，最少拥有一个线程，而线程就是CPU调度的最小单位。

所以线程是进程的一个子任务，多线程也就是进程中多个子任务并发执行。
实际上CPU单次调度只执行一个线程，并发的原理就是操作系统在多个线程之间快速切换，
让每个线程都短暂的交替运行。

python的多线程主要就是使用高级模块threading。而且的python的多线程很有特点。
以CPython为例，他受限于GIL全局排它锁，在某个threading编写多任务程序中，所有的线程，
只能在一个CPU中调度。调度其实是操作系统的事情，全局锁的意思就是，在每次线程切换的时候，
都会上锁。目的是为了保证线程之间数据一致性和状态同步。

因为多线程与多进程最大的不同，就是多进程中每个进程都有自己的一份数据拷贝，相互不影响。
而多线则共享其任务进程的数据资源，这也是GIL全局排他锁存在的原因。


#### 线程本地数据


#### 多进程


#### 协程
协程。我们也可以叫微线程。

在线程中，将每个函数的执行视为一个子程序。多个子程序之间的调用，必然为有序性和层次性。
而且一个子程序调用，总是一个入口，然后对应返回。

例如函数A调用了函数B，函数B中又调用了C，那么顺序为C调用结束后返回，接着B调用结束后返回，
最后才是A执行返回。这种是通过栈结构实现的。

协程不同。同一线程中，不同子程序之间的执行，是可中断的。中断处由开发人员设计，
中断后子程序内部保留既有属性与方法，转而执行其他子程序，在适当的时候在返回中断处继续执行。

异步编程中，最经典的就是异步回调式编程。也就在发生阻塞IO事件时，不进行显示的等待，
只是注册回调事件后转而执行其他程序。当阻塞事件完成后，即可执行已注册事件，继而完成后续的操作。
而协程式异步编程，则没有显示的回调逻辑，则整体编写的代码看上去与同步编程基本上是相同的。
因为协程本身中断后不会影响既有属性与方法，只需要重新激活协程即可继续执行后续代码。

本质上协程式异步编程，也是基于回调式。不过原生库asyncio帮我们封装好了回调逻辑。
将一个协程打包为一个Task任务并添加到期程，返回对应的未来对象。

总体流程就是：
发生IO耗时事件（常见的阻塞IO包括读写IO和网络IO，操作系统将事件分为两类，
也就是可读事件和可写事件）。程序会将此事件注册回调，转而执行其他程序，
当事件状态改变时即会触发回调。