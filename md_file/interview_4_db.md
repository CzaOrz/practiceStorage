### [Database](#Database)
* [事务](#事务)
* [隔离级别](#隔离级别)

----------

## Database

#### 事务
事务就是作为单个逻辑单元执行的一组操作，要么全成功，要么全失败。<br>
这种把多条语句作为一个整体进行操作的功能，称之为数据库事务。
* A-原子性：将所有的SQL作为原子工作单元执行，即要么全执行，要么全不执行。
* C-一致性：事务完成后，所有数据的状态需要一致。
* I-隔离性：多个事务并发执行，每个事务作出的修改必须与其他事务隔离。
* D-持久性：事务完成后，对数据库的修改应该被持久化存储。

对于单条SQL语句，数据库自动将其作为一个事务执行，这种事务被称之为```隐式事务```<br>
而当需要把多条SQL语句作为一个事务执行，则需要使用BEGIN开启一个事务，
使用COMMIT提交一个事务，这种事务被称之为显式事务。
```SQL
BEGIN;
UPDATE account SET balance=balance-100 WHERE id=1;
UPDATE account SET balance=balance+100 WHERE id=2;
COMMIT;
```
当我们希望主动让事务失败，则需要使用ROOLBACK回滚事务，即整个事务会失败：
```SQL
BEGIN;
UPDATE account SET balance=balance-100 WHERE id=1;
UPDATE account SET balance=balance+100 WHERE id=2;
ROOLBACK;
```

#### 隔离级别
##### Read Uncommitted
是隔离级别最低的一种事务级别。在此隔离级别下，一个事务会读到另一个
事务更新后但未提交的数据。<br>
若另一个事务回滚，那么当前事务读到的数据就是脏数据，即Dirty Read<br>

事务A、B
* A：更新了事件但是没有commit，此时B读取到的就是更新后的数据
* B：随后A进行事务回滚，B再度就又得到不同的数据，这就是脏读
总结来说就是：<br>
在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据

##### Read Committed
在此隔离级别下，一个事务可能会遇到不可重复读的问题。<br>
就是一个事务在两次读取数据的过程中，当有另一个事务同样修改了当前数据，
并且对事务进行了commit。那么前一个事务再次读取就会得到不同数据。

##### Repeatable Read
在此隔离级别下，一个事务可能会遇到幻读Phantom Read。<br>
幻读即，在一个事务中，第一次查询某条记录是发现没有，但是当更新
这条不存在的数据时能够成功密切再次读取同一记录是，能够查询到。<br>

当一个事务进行查询为空时，另一个事务插入了这条数据。然后第一个事务
再次查询结果仍然为空，但是更新这条数据是可以成功的，之后再查就可以出结果。

##### Serializable
Serializable是最严格的隔离级别。在此级别下所有事务按照次序一次执行。
因此脏读、不可重复读、幻读都不会出现。<br>
但是事务的执行是串联执行的，效率会降低。<br>
在mysql的InnoDB引擎，默认的隔离级别是Repeatable Read


