### [Database](#Database)
* [事务](#事务)
* [分布式事务](#分布式事务)
* [隔离级别](#隔离级别)

----------

## Database

#### 事务
事务就是作为单个逻辑单元执行的一组操作，要么全成功，要么全失败。<br>
这种把多条语句作为一个整体进行操作的功能，称之为数据库事务。
* A-原子性：将所有的SQL作为原子工作单元执行，即要么全执行，要么全不执行。
* C-一致性：事务完成后，所有数据的状态需要一致。
* I-隔离性：多个事务并发执行，每个事务作出的修改必须与其他事务隔离。
* D-持久性：事务完成后，对数据库的修改应该被持久化存储。

对于单条SQL语句，数据库自动将其作为一个事务执行，这种事务被称之为```隐式事务```<br>
而当需要把多条SQL语句作为一个事务执行，则需要使用BEGIN开启一个事务，
使用COMMIT提交一个事务，这种事务被称之为显式事务。
```SQL
BEGIN;
UPDATE account SET balance=balance-100 WHERE id=1;
UPDATE account SET balance=balance+100 WHERE id=2;
COMMIT;
```
当我们希望主动让事务失败，则需要使用ROOLBACK回滚事务，即整个事务会失败：
```SQL
BEGIN;
UPDATE account SET balance=balance-100 WHERE id=1;
UPDATE account SET balance=balance+100 WHERE id=2;
ROOLBACK;
```

#### 分布式事务
单数据源的一致性依靠单机事务来保证，多数据源的一致性就要依靠分布式事务。<br>
* XA分布式事务协议
    * 包含两阶段提交（2PC）和三阶段提交（3PC）
    * 2PC
        * 在XA协议中包含着两个角色：事务的协调者和事务参与者
        * 第一阶段：作为事务的协调者首先会向所有的参与者节点发送Prepare请求<br>
        在接收到请求之后，每一个节点各自执行与事务相关的数据更新，但是不提交事务<br>
        而是向事务协调者返回完成的消息
        * 第二阶段：事务协调者接收到了所有参与者的返回正向消息，则发出commit请求。<br>
        当节点成功commit提交后，会发送确认的消息，至此，整个分布式事务完成。
    * 2PC的缺点：
        * 性能问题：虽遵循强一致性，但事务执行过程中，各节点占用这数据资源<br>
        只有当所有节点准备完毕，事务协调者才会通知提交，然后参与者才会释放资源。
        * 协调者单点故障：协调者单点挂了，基本就无法完成工作。
        * 丢失消息导致不一致：即在第二阶段，发送commit的过程中，某节点未收到消息<br>
        则会导致数据的不一致性。
    * 3PC
        * 在原基础上增加了CanCommit阶段，并引入了超时机制，一旦事务参与者迟迟没有
        接到协调者的commit请求，会自动本地commit。
    * MQ事务：
        * 利用中间件来异步完成事件的后一半更新。
    * TCC事务：
        * 即Try、Commit、Cancel。

#### 隔离级别
##### Read Uncommitted
是隔离级别最低的一种事务级别。在此隔离级别下，一个事务会读到另一个
事务更新后但未提交的数据。<br>
若另一个事务回滚，那么当前事务读到的数据就是脏数据，即Dirty Read<br>

事务A、B
* A：更新了事件但是没有commit，此时B读取到的就是更新后的数据
* B：随后A进行事务回滚，B再度就又得到不同的数据，这就是脏读
总结来说就是：<br>
在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据

##### Read Committed
在此隔离级别下，一个事务可能会遇到不可重复读的问题。<br>
就是一个事务在两次读取数据的过程中，当有另一个事务同样修改了当前数据，
并且对事务进行了commit。那么前一个事务再次读取就会得到不同数据。

##### Repeatable Read
在此隔离级别下，一个事务可能会遇到幻读Phantom Read。<br>
幻读即，在一个事务中，第一次查询某条记录是发现没有，但是当更新
这条不存在的数据时能够成功密切再次读取同一记录是，能够查询到。<br>

当一个事务进行查询为空时，另一个事务插入了这条数据。然后第一个事务
再次查询结果仍然为空，但是更新这条数据是可以成功的，之后再查就可以出结果。

##### Serializable
Serializable是最严格的隔离级别。在此级别下所有事务按照次序一次执行。
因此脏读、不可重复读、幻读都不会出现。<br>
但是事务的执行是串联执行的，效率会降低。<br>
在mysql的InnoDB引擎，默认的隔离级别是Repeatable Read


