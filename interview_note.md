### [Python](#Python)
* [什么是函数的参数](#函数的参数)
* [什么是高阶函数](#高阶函数)
* [什么是闭包](#闭包)
* [什么是装饰器](#装饰器)
* [什么是偏函数](#偏函数)
* [什么是迭代器](#迭代器)
* [什么是单例模式](#单例模式)
* [什么是多线程](#多线程)
* [什么是线程本地数据](#线程本地数据)
* [什么是多进程](#多进程)
* [什么是协程](#协程)

### [Spider](#Spider)

### [Web](#Web)
* [TCP握手协议](#TCP握手协议)
* [HTTP](#HTTP)
* [WSGI](#WSGI)
* [MVC](#MVC)
* [Flask](#Flask)
* [Django](#Django)

### [Other](#Other)
* [什么是面向过程的程序设计](#面向过程的程序设计)



## python
#### 函数的参数
包括位置参数、默认参数、可变参数、关键字参数、命名关键字参数
* 位置参数：定义后按顺序传入参数。```def test(x, y, z): ...```
* 默认参数：定义函数时，设定好参数的默认值。```def test(x, y, z="default"): ...```
* 可变参数：允许动态的传入参数。```def test(x, *args): ...```
* 关键字参数：允许动态的传入命名参数。```def test(x, *args, **kwargs): ...```
* 命名关键字参数：限定传入的命名参数。```def test(x, *args, key1, key2): ... ```

#### 高阶函数
一个函数可以接收另一个函数作为参数，或一盒函数返回值为函数，则称之为高阶函数


#### 闭包
当一个高阶函数，返回一个新函数的时候，高阶函数内部的局部变量被新函数引用，这种情况属于闭包。

更详细点就是，函数定义中引用了函数外定义的变量，并且该函数可以在其定义外环境被执行。


#### 装饰器
本质上，装饰器就是一个返回函数的高阶函数。
```
def decorator(func=None):
    def wrapper():
        return func()
    return wrapper
```


#### 偏函数
在python中可通过```functools.partial```来实现。原理就是对于一个已有函数，
通过将某些参数给固定住，从而返回一个新函数。调用这个新函数会更简单。
```
from functools import partial
new_func = partial(int, base=2)
print(new_func('123'))  # default base is 2
```


#### 迭代器
可以用做for循环的数据类型包括：
* 集合数据类型。包括list、dict、tuple、set、str等
* 生成器
可以直接作用于for循环的对象，统称为可迭代对象。Iterable

而可以被next()函数调用并不断返回下一个值的对象，统称为迭代器。Iterator。

可迭代对象可通过iter()函数转化为迭代器。


#### 单例模式
单例模式。在程序生命周期中，确保一个类只有一个实例。
```
class SingleInstance:
    instance = None
    def get_instance(self):
        if not self.instance:
            self.instance = True  # create one instance in here
        return self.instance
```


#### 多线程
首先得从`多任务`操作系统说起。多任务的意思就是：我们边听歌，边打游戏。就用户的感觉而言，
他们是一起执行的，当然后台肯定有其他任务也在一起执行。对于操作系统而言，
一个任务就是一个进程，一个进程，最少拥有一个线程，而线程就是CPU调度的最小单位。

所以线程是进程的一个子任务，多线程也就是进程中多个子任务并发执行。
实际上CPU单次调度只执行一个线程，并发的原理就是操作系统在多个线程之间快速切换，
让每个线程都短暂的交替运行。

python的多线程主要就是使用高级模块threading。而且的python的多线程很有特点。
以CPython为例，他受限于GIL全局排它锁，在某个threading编写多任务程序中，所有的线程，
只能在一个CPU中调度。调度其实是操作系统的事情，全局锁的意思就是，在每次线程切换的时候，
都会上锁。目的是为了保证线程之间数据一致性和状态同步。

因为多线程与多进程最大的不同，就是多进程中每个进程都有自己的一份数据拷贝，相互不影响。
而多线则共享其任务进程的数据资源，这也是GIL全局排他锁存在的原因。


#### 线程本地数据


#### 多进程


#### 协程
协程。我们也可以叫微线程。

在线程中，将每个函数的执行视为一个子程序。多个子程序之间的调用，必然为有序性和层次性。
而且一个子程序调用，总是一个入口，然后对应返回。

例如函数A调用了函数B，函数B中又调用了C，那么顺序为C调用结束后返回，接着B调用结束后返回，
最后才是A执行返回。这种是通过栈结构实现的。

协程不同。同一线程中，不同子程序之间的执行，是可中断的。中断处由开发人员设计，
中断后子程序内部保留既有属性与方法，转而执行其他子程序，在适当的时候在返回中断处继续执行。

异步编程中，最经典的就是异步回调式编程。也就在发生阻塞IO事件时，不进行显示的等待，
只是注册回调事件后转而执行其他程序。当阻塞事件完成后，即可执行已注册事件，继而完成后续的操作。
而协程式异步编程，则没有显示的回调逻辑，则整体编写的代码看上去与同步编程基本上是相同的。
因为协程本身中断后不会影响既有属性与方法，只需要重新激活协程即可继续执行后续代码。

本质上协程式异步编程，也是基于回调式。不过原生库asyncio帮我们封装好了回调逻辑。
将一个协程打包为一个Task任务并添加到期程，返回对应的未来对象。

总体流程就是：
发生IO耗时事件（常见的阻塞IO包括读写IO和网络IO，操作系统将事件分为两类，
也就是可读事件和可写事件）。程序会将此事件注册回调，转而执行其他程序，
当事件状态改变时即会触发回调。

## Spider

## web
web应用的本质。客户端发起HTTP请求，服务端接收请求作出回应，比如生成一个Html文件，
然后服务器把此Html文件作为HTTP响应的Body发送给客户端，由客户端进行后续的显示处理。


#### TCP握手协议


#### HTTP
HTTP是一种文本协议，也是常用的网络通信协议。

一次HTTP事件，包含Header和Body。事件通常分为请求事件和响应事件。

请求事件Header中，主要报头和报文。Body是根据请求方式的可选事件
* **GET / HTTP/1.1** 报头包含请求方式、请求路径、协议版本
* **Host: www.google.com** 报文则由Key:Value的结构组成

响应事件Header中，也包括报头和报文，Body就是我们在浏览器中能看到的内容
* **HTTP/1.1 200 OK** 响应报头中包含协议版本、响应状态码、信息说明
* **X-Powered-By: Express** 报文则一样，由Key:Value的结构组成

Header之间以\r\n进行划分，出现两个\r\n\r\n，则后面的数据全为body。

200成功、3xx重定向、4xx客户端异常、5xx服务端异常


#### WSGI
**Web-Server-Gateway-Interface** web服务器网关接口

最简单的web应用就是先把html文件保存好，用先有的HTTP服务器接受用户请求，然后直接返回已有的html文件。
这就是我们常说的静态服务器，如Nginx等。

而实际上一个web应用可能复杂的多，需要我们获取HTTP请求信息并解析，然后做出对应的处理再打包返回。
故为了简化开发，WSGI接口出现了。他实现了对HTTP请求的初步包装，以便web应用进行后续的处理。

一个WSGI接口，封装HTTP请求后，会为web应用提供两个参数，分别为environ和start_response。
* **environ** 此参数是一个dict对象，包含有完整的HTTP请求信息
* **start_response** 此参数是一个函数对象，是用于发送HTTP响应报文的函数

web应用，从WSGI接口中获取这两个参数并进行后续的处理，业务逻辑完成后。
调用且仅能调用一次start_response函数，用于返回响应报文
```start_response("200 fucking", [("Content-Type", "this/is/a/joking")])```，
此函数接受两个参数，第一个是响应报头，里面包含状态码和信息说明。第二个是响应报文，是一个list，
子元素是tuple，tuple内部为两个string，分别对应着报文中的Key:Value
```
from wsgiref.simple_server import make_server
def test_app(environ, start_response):
    start_response("200 fucking-man", [("Content-Type", "text/html")])
    return [b"hello, funking man"]
web = make_server("", 8888, test_app)
web.serve_forever()
```


#### MVC
Model-View-Controller ―― 模型-视图-控制器

python后端代码中，负责处理路由的函数或者类，就是控制器，主要负责业务逻辑

而像jinjia2或Django自带模板框架，里面一些带有{{}}特殊变量的文件，就是视图，主要负责显示逻辑。
也就是通过一些简单的替换，生成最终的显示页面。

而业务逻辑 传递给 显示逻辑 的部分，即是Model模板。本质上是一个字典，也是一个映射表。
作用还是为了渲染视图，生成目标模板

MVC架构，初步拆离了业务逻辑与显示逻辑。


#### Flask


#### Django

## Other

#### 面向过程的程序设计
函数是编程语言通用的一种封装，通过将大段代码拆分为函数，通过一层一层的函数调用，
就可以把一个复杂任务拆分为多个简单任务，这种分解就是面向过程的程序设计。
而函数就是面向过程的程序设计的基本单元。