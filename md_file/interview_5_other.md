### [Other](#Other)
* [什么是面向过程的程序设计](#面向过程的程序设计)
* [RabbitMQ](#RabbitMQ)
* [负载均衡](#负载均衡)

----------

## Other

#### 面向过程的程序设计
函数是编程语言通用的一种封装，通过将大段代码拆分为函数，通过一层一层的函数调用，
就可以把一个复杂任务拆分为多个简单任务，这种分解就是面向过程的程序设计。
而函数就是面向过程的程序设计的基本单元。

#### RabbitMQ
* broker: 消息队列服务器实体
* virtual host: 虚拟主机。默认vhost为/，每个vhost本质上就是一个mini版的rabbitmq服务器，拥有自己的队列、交换器、绑定和权限机制。可以理解为是一个自己的账号。
* exchange: 交换器，用来接收生产者发送给消费者的消息，并将这些消息路由给服务器的队列
* queue: 消息队列，用来保存消息知道发送给消费者。是消息的容器，也是消息的终点。一条消息可投入一个/多个队列。期间消息一直在队列中，等待消费者连接这个队列并取走。
* banding: 绑定，用于消息队列和交换机之间的关联。一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则，所以可以将交换器理解为一个由绑定构成的路由表。
* channel: 信道，多路复用连接中的一条独立的双向数据流通道。因为对于操作系统而言，建立和销毁TCP都有一定开销，故引入信道概念，复用一条TCP。<br>
amqp命令都是通过信道发出去的，如发布消息、订阅消息、或者或者是接收消息。
* connection: 网络连接。如TCP连接
* publisher: 消息生产者，可以使一个向交换器发布消息的客户端应用程序
* consumer: 消息消费者，从某消息队列取得消息的客户端应用程序
* message: 消息，消息不具名，由消息头和消息体组成。消息头由一系列可选属性组成，<br>
包括routing-key（路由键）、priority（优先级）、delivery-mode（消息可能需要序列化存储【消息的理由模式】）

exchange类型<br>
* direct: 消息中的路由键（routing-key）如果和binging中的binding-key一致。交换器就将消息队列发到对应的队列中。即路由与队列名完全匹配。
* fanout: 交换器的消息会分发到所有绑定的队列中。fanout交换器不处理该路由键，只是简单的将队列绑定到交换器上，<br>
每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。fanout类型转发消息最快。
* topic: topic交换器通过模式匹配分配消息的路由属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。<br>
识别两个通配符#*，#匹配多个单词，*则匹配一个单词。


#### 负载均衡
* HTTP重定向
    * 通过web服务器中的Location报文头，指向真正的工作服务器
* DNS负载均衡
    * DNS服务器充当主站点，将用户请求的域名映射为实际的IP地址，这种映射是可以一对多。
    即DNS的A记录，用来指定域名对应的IP地址
* 反向代理
    * 反向代理的核心就是转发HTTP，任何实际服务器的HTTP请求都需要经过调度器，而调度器
    则等待实际服务器的HTTP响应，并将之反馈给用户。





