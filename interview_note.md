### [Python](#Python)
* [List](#list)
* [Dict](#dict)
* [什么是函数的参数](#函数的参数)
* [什么是高阶函数](#高阶函数)
* [什么是闭包](#闭包)
* [什么是装饰器](#装饰器)
* [什么是偏函数](#偏函数)
* [什么是迭代器](#迭代器)
* [什么是单例模式](#单例模式)
* [什么是多线程](#多线程)
* [什么是线程本地数据](#线程本地数据)
* [什么是多进程](#多进程)
* [什么是协程](#协程)

### [Spider](#Spider)

### [Web](#Web)
* [TCP握手协议](#TCP握手协议)
* [HTTP](#HTTP)
* [WSGI](#WSGI)
* [MVC](#MVC)
* [Flask](#Flask)
* [Django](#Django)

### [Other](#Other)
* [什么是面向过程的程序设计](#面向过程的程序设计)
* [RabbitMQ](#RabbitMQ)



## python
#### list
数据结构：有一个指针数组用来保存列表元素的指针，和一个可以在列表中放多少元素的标记
```
typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;  // 指向列表元素的指针数组
    Py_ssize_t allocated;  // 申请的内存的槽的个数
} PyListObject;
```
python中的list是对其他对象的引用组成连续数组

#### dict
###### 解释器赋值：
* a = 'ABC': 解释器做了两件事
    * 在内存中创建了一个'ABC'的字符串对象
    * 在内存中创建了一个 a 的变量，并把它指向了 'ABC' 这个字符串对象
        
把一个变量a的值赋值给另一个变量b，实际就是把变量b指向了变量a所指向的数据
###### 可散列类型：
* 在可散列对象的生命周期中，他的散列值是不变的。需要实现__hash__和__eq__两个方法，
若两个可散列对象是相同的，则散列值一定是一样的
* ```a, b = "123", "".join(["1", "2", "3"])```,则```id(a) == id(b)  # False```，
因为二者已经不是同一对象，也就是```a is b  # False```，但值是相等的，即```a == b  # True```。
散列值/哈希值也是相等的```hash(a) == hash(b)  # True``` 
###### 稀疏数组：
* 所谓稀疏数组就是数组中大部分的内容都未被使用，或者都是零。<br>
数组中仅有少部分空间是有效使用的，因此有一定的空间浪费。

python中dict的底层数据结构是一个散列表，而散列表其实是一个稀疏数组<br>
散列表的里的每一个单元，我们称之为表元。也就是说在dict的散列表中，一个有效的表元其实分为两部分，
一个是对键的引用，一个是对值的引用。<br>
而表元大小一样，故可以通过偏移量来读取每一个表元。
##### 计算方式：
* 计算键的散列值
* 使用散列值中的一部分来定位散列表中的一个表元
    * 表元为空: 抛出异常KeyError
    * 键不相等:
        * 散列冲突
        * 取散列值另一部分来定位
        * 循环
    * 返回表元中的值

由于这种特性，导致字典：
1、键：必须为可散列，是为了能够唯一定位。
2、在空间上开销大：
3、散列冲突会导致字典内无序

#### 函数的参数
包括位置参数、默认参数、可变参数、关键字参数、命名关键字参数
* 位置参数：定义后按顺序传入参数。```def test(x, y, z): ...```
* 默认参数：定义函数时，设定好参数的默认值。```def test(x, y, z="default"): ...```
* 可变参数：允许动态的传入参数。```def test(x, *args): ...```
* 关键字参数：允许动态的传入命名参数。```def test(x, *args, **kwargs): ...```
* 命名关键字参数：限定传入的命名参数。```def test(x, *args, key1, key2): ... ```

#### 高阶函数
一个函数可以接收另一个函数作为参数，或一盒函数返回值为函数，则称之为高阶函数


#### 闭包
当一个高阶函数，返回一个新函数的时候，高阶函数内部的局部变量被新函数引用，这种情况属于闭包。

更详细点就是，函数定义中引用了函数外定义的变量，并且该函数可以在其定义外环境被执行。


#### 装饰器
本质上，装饰器就是一个返回函数的高阶函数。
```
def decorator(func=None):
    def wrapper():
        return func()
    return wrapper
```


#### 偏函数
在python中可通过```functools.partial```来实现。原理就是对于一个已有函数，
通过将某些参数给固定住，从而返回一个新函数。调用这个新函数会更简单。
```
from functools import partial
new_func = partial(int, base=2)
print(new_func('123'))  # default base is 2
```


#### 迭代器
可以用做for循环的数据类型包括：
* 集合数据类型。包括list、dict、tuple、set、str等
* 生成器
可以直接作用于for循环的对象，统称为可迭代对象。Iterable

而可以被next()函数调用并不断返回下一个值的对象，统称为迭代器。Iterator。

可迭代对象可通过iter()函数转化为迭代器。


#### 单例模式
单例模式。在程序生命周期中，确保一个类只有一个实例。
```
class SingleInstance:
    instance = None
    def get_instance(self):
        if not self.instance:
            self.instance = True  # create one instance in here
        return self.instance
```


#### 多线程
首先得从`多任务`操作系统说起。多任务的意思就是：我们边听歌，边打游戏。就用户的感觉而言，
他们是一起执行的，当然后台肯定有其他任务也在一起执行。对于操作系统而言，
一个任务就是一个进程，一个进程，最少拥有一个线程，而线程就是CPU调度的最小单位。

所以线程是进程的一个子任务，多线程也就是进程中多个子任务并发执行。
实际上CPU单次调度只执行一个线程，并发的原理就是操作系统在多个线程之间快速切换，
让每个线程都短暂的交替运行。

python的多线程主要就是使用高级模块threading。而且的python的多线程很有特点。
以CPython为例，他受限于GIL全局排它锁，在某个threading编写多任务程序中，所有的线程，
只能在一个CPU中调度。调度其实是操作系统的事情，全局锁的意思就是，在每次线程切换的时候，
都会上锁。目的是为了保证线程之间数据一致性和状态同步。

因为多线程与多进程最大的不同，就是多进程中每个进程都有自己的一份数据拷贝，相互不影响。
而多线则共享其任务进程的数据资源，这也是GIL全局排他锁存在的原因。


#### 线程本地数据


#### 多进程


#### 协程
协程。我们也可以叫微线程。

在线程中，将每个函数的执行视为一个子程序。多个子程序之间的调用，必然为有序性和层次性。
而且一个子程序调用，总是一个入口，然后对应返回。

例如函数A调用了函数B，函数B中又调用了C，那么顺序为C调用结束后返回，接着B调用结束后返回，
最后才是A执行返回。这种是通过栈结构实现的。

协程不同。同一线程中，不同子程序之间的执行，是可中断的。中断处由开发人员设计，
中断后子程序内部保留既有属性与方法，转而执行其他子程序，在适当的时候在返回中断处继续执行。

异步编程中，最经典的就是异步回调式编程。也就在发生阻塞IO事件时，不进行显示的等待，
只是注册回调事件后转而执行其他程序。当阻塞事件完成后，即可执行已注册事件，继而完成后续的操作。
而协程式异步编程，则没有显示的回调逻辑，则整体编写的代码看上去与同步编程基本上是相同的。
因为协程本身中断后不会影响既有属性与方法，只需要重新激活协程即可继续执行后续代码。

本质上协程式异步编程，也是基于回调式。不过原生库asyncio帮我们封装好了回调逻辑。
将一个协程打包为一个Task任务并添加到期程，返回对应的未来对象。

总体流程就是：
发生IO耗时事件（常见的阻塞IO包括读写IO和网络IO，操作系统将事件分为两类，
也就是可读事件和可写事件）。程序会将此事件注册回调，转而执行其他程序，
当事件状态改变时即会触发回调。

## Spider

## web
web应用的本质。客户端发起HTTP请求，服务端接收请求作出回应，比如生成一个Html文件，
然后服务器把此Html文件作为HTTP响应的Body发送给客户端，由客户端进行后续的显示处理。


#### TCP握手协议


#### HTTP
HTTP是一种文本协议，也是常用的网络通信协议。

一次HTTP事件，包含Header和Body。事件通常分为请求事件和响应事件。

请求事件Header中，主要报头和报文。Body是根据请求方式的可选事件
* **GET / HTTP/1.1** 报头包含请求方式、请求路径、协议版本
* **Host: www.google.com** 报文则由Key:Value的结构组成

响应事件Header中，也包括报头和报文，Body就是我们在浏览器中能看到的内容
* **HTTP/1.1 200 OK** 响应报头中包含协议版本、响应状态码、信息说明
* **X-Powered-By: Express** 报文则一样，由Key:Value的结构组成

Header之间以\r\n进行划分，出现两个\r\n\r\n，则后面的数据全为body。

200成功、3xx重定向、4xx客户端异常、5xx服务端异常


#### WSGI
**Web-Server-Gateway-Interface** web服务器网关接口

最简单的web应用就是先把html文件保存好，用先有的HTTP服务器接受用户请求，然后直接返回已有的html文件。
这就是我们常说的静态服务器，如Nginx等。

而实际上一个web应用可能复杂的多，需要我们获取HTTP请求信息并解析，然后做出对应的处理再打包返回。
故为了简化开发，WSGI接口出现了。他实现了对HTTP请求的初步包装，以便web应用进行后续的处理。

一个WSGI接口，封装HTTP请求后，会为web应用提供两个参数，分别为environ和start_response。
* **environ** 此参数是一个dict对象，包含有完整的HTTP请求信息
* **start_response** 此参数是一个函数对象，是用于发送HTTP响应报文的函数

web应用，从WSGI接口中获取这两个参数并进行后续的处理，业务逻辑完成后。
调用且仅能调用一次start_response函数，用于返回响应报文
```start_response("200 fucking", [("Content-Type", "this/is/a/joking")])```，
此函数接受两个参数，第一个是响应报头，里面包含状态码和信息说明。第二个是响应报文，是一个list，
子元素是tuple，tuple内部为两个string，分别对应着报文中的Key:Value
```
from wsgiref.simple_server import make_server
def test_app(environ, start_response):
    start_response("200 fucking-man", [("Content-Type", "text/html")])
    return [b"hello, funking man"]
web = make_server("", 8888, test_app)
web.serve_forever()
```


#### MVC
Model-View-Controller ―― 模型-视图-控制器

python后端代码中，负责处理路由的函数或者类，就是控制器，主要负责业务逻辑

而像jinjia2或Django自带模板框架，里面一些带有{{}}特殊变量的文件，就是视图，主要负责显示逻辑。
也就是通过一些简单的替换，生成最终的显示页面。

而业务逻辑 传递给 显示逻辑 的部分，即是Model模板。本质上是一个字典，也是一个映射表。
作用还是为了渲染视图，生成目标模板

MVC架构，初步拆离了业务逻辑与显示逻辑。


#### Flask


#### Django

## Other

#### 面向过程的程序设计
函数是编程语言通用的一种封装，通过将大段代码拆分为函数，通过一层一层的函数调用，
就可以把一个复杂任务拆分为多个简单任务，这种分解就是面向过程的程序设计。
而函数就是面向过程的程序设计的基本单元。

#### RabbitMQ
* broker: 消息队列服务器实体
* virtual host: 虚拟主机。默认vhost为/，每个vhost本质上就是一个mini版的rabbitmq服务器，拥有自己的队列、交换器、绑定和权限机制。可以理解为是一个自己的账号。
* exchange: 交换器，用来接收生产者发送给消费者的消息，并将这些消息路由给服务器的队列
* queue: 消息队列，用来保存消息知道发送给消费者。是消息的容器，也是消息的终点。一条消息可投入一个/多个队列。期间消息一直在队列中，等待消费者连接这个队列并取走。
* banding: 绑定，用于消息队列和交换机之间的关联。一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则，所以可以将交换器理解为一个由绑定构成的路由表。
* channel: 信道，多路复用连接中的一条独立的双向数据流通道。因为对于操作系统而言，建立和销毁TCP都有一定开销，故引入信道概念，复用一条TCP。<br>
amqp命令都是通过信道发出去的，如发布消息、订阅消息、或者或者是接收消息。
* connection: 网络连接。如TCP连接
* publisher: 消息生产者，可以使一个向交换器发布消息的客户端应用程序
* consumer: 消息消费者，从某消息队列取得消息的客户端应用程序
* message: 消息，消息不具名，由消息头和消息体组成。消息头由一系列可选属性组成，<br>
包括routing-key（路由键）、priority（优先级）、delivery-mode（消息可能需要序列化存储【消息的理由模式】）

exchange类型<br>
* direct: 消息中的路由键（routing-key）如果和binging中的binding-key一致。交换器就将消息队列发到对应的队列中。即路由与队列名完全匹配。
* fanout: 交换器的消息会分发到所有绑定的队列中。fanout交换器不处理该路由键，只是简单的将队列绑定到交换器上，<br>
每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。fanout类型转发消息最快。
* topic: topic交换器通过模式匹配分配消息的路由属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。<br>
识别两个通配符#*，#匹配多个单词，*则匹配一个单词。
